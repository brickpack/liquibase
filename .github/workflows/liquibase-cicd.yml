name: Liquibase CI/CD

on:
  push:
    branches-ignore: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, closed]
  workflow_dispatch:
    inputs:
      database:
        description: 'Database to target (or all)'
        required: false
        default: 'all'
        type: string
      action:
        description: 'Action to perform'
        required: false
        default: 'auto'
        type: choice
        options:
        - auto
        - test
        - deploy
        - reset

permissions:
  id-token: write
  contents: read

jobs:
  discover-databases:
    runs-on: ubuntu-latest
    outputs:
      databases: ${{ steps.discover.outputs.databases }}
      test-mode: ${{ steps.determine-mode.outputs.test-mode }}
      reset-mode: ${{ steps.determine-mode.outputs.reset-mode }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Discover databases
      id: discover
      run: |
        databases=$(find . -name "changelog-*.xml" -type f | grep -v "changelog-bootstrap.xml" | sed 's|./changelog-||g' | sed 's|\.xml||g' | jq -R -s -c 'split("\n")[:-1]')
        echo "Found databases: $databases"
        echo "databases=$databases" >> $GITHUB_OUTPUT

    - name: Determine execution mode
      id: determine-mode
      run: |
        echo "üîç Event details:"
        echo "   Event name: ${{ github.event_name }}"
        echo "   Action: ${{ github.event.action }}"
        echo "   PR merged: ${{ github.event.pull_request.merged }}"
        echo "   Base ref: ${{ github.event.pull_request.base.ref }}"
        echo "   Head ref: ${{ github.event.pull_request.head.ref }}"
        echo ""

        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          if [[ "${{ github.event.inputs.action }}" == "test" ]]; then
            echo "üß™ Manual test mode requested"
            echo "test-mode=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.inputs.action }}" == "deploy" ]]; then
            echo "üöÄ Manual deploy mode requested"
            echo "test-mode=false" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.inputs.action }}" == "reset" ]]; then
            echo "üîÑ Manual reset mode requested - will clear tracking and redeploy"
            echo "test-mode=false" >> $GITHUB_OUTPUT
            echo "reset-mode=true" >> $GITHUB_OUTPUT
          else
            # Auto mode - never deploy in manual auto mode, always test
            echo "üß™ Manual auto mode - running tests only"
            echo "test-mode=true" >> $GITHUB_OUTPUT
          fi
        elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "closed" && "${{ github.event.pull_request.merged }}" == "true" && "${{ github.event.pull_request.base.ref }}" == "main" ]]; then
          echo "üöÄ PR merged to main - running DEPLOYMENT"
          echo "test-mode=false" >> $GITHUB_OUTPUT
        else
          echo "üß™ Branch push or PR opened/updated - running TESTS only"
          echo "test-mode=true" >> $GITHUB_OUTPUT
        fi

  liquibase:
    needs: discover-databases
    runs-on: ubuntu-latest
    strategy:
      matrix:
        database: ${{ fromJson(needs.discover-databases.outputs.databases) }}
      fail-fast: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Skip if specific database selected
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.database != 'all' && github.event.inputs.database != matrix.database
      run: |
        echo "Skipping ${{ matrix.database }} as ${{ github.event.inputs.database }} was selected"
        exit 0

    - name: Configure AWS credentials
      if: needs.discover-databases.outputs.test-mode == 'false'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

    - name: Set up Java
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Setup Liquibase and drivers
      run: ./.github/scripts/setup-liquibase-minimal.sh

    - name: Analyze changelog structure
      run: ./.github/scripts/analyze-changelog.sh ${{ matrix.database }}

    - name: Validate SQL syntax
      run: |
        echo "üîç Validating SQL syntax for ${{ matrix.database }}..."

        # Find all SQL files referenced by this changelog
        SQL_FILES=$(grep -o 'file="[^"]*\.sql"' changelog-${{ matrix.database }}.xml | sed 's/file="//g' | sed 's/"//g')

        if [ -z "$SQL_FILES" ]; then
          echo "‚ÑπÔ∏è No SQL files found to validate"
          exit 0
        fi

        echo "üìÑ Found SQL files to validate:"
        echo "$SQL_FILES"
        echo ""

        # Check each SQL file for basic syntax issues
        VALIDATION_ERRORS=0

        for sql_file in $SQL_FILES; do
          if [ ! -f "$sql_file" ]; then
            echo "‚ùå File not found: $sql_file"
            VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            continue
          fi

          echo "üîç Validating: $sql_file"

          # Check for common SQL syntax issues
          # 1. Check for unterminated quotes
          quote_error=0
          grep -n "'\|\"" "$sql_file" | grep -v "^[[:space:]]*--" | while read -r line; do
            line_num=$(echo "$line" | cut -d: -f1)
            content=$(echo "$line" | cut -d: -f2-)

            # Count single quotes (ignoring comments)
            single_quotes=$(echo "$content" | grep -o "'" | wc -l)
            if [ $((single_quotes % 2)) -ne 0 ]; then
              echo "‚ö†Ô∏è  Line $line_num: Possible unterminated single quote"
              echo "1" > /tmp/quote_error_$$.tmp
            fi
          done
          
          if [ -f "/tmp/quote_error_$$.tmp" ]; then
            echo "‚ùå Quote validation failed for $sql_file"
            VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            rm -f /tmp/quote_error_$$.tmp
          fi

          # 2. Check for dollar quote issues
          # Extract all dollar quote tags from the entire file
          dollar_tags=$(grep -o '\$[^$]*\$' "$sql_file" | sort | uniq -c)
          
          # Check if each tag appears an even number of times
          dollar_quote_error=0
          while read -r count tag; do
            if [ -n "$tag" ] && [ $((count % 2)) -ne 0 ]; then
              echo "‚ö†Ô∏è  Unmatched dollar quote tag: $tag (appears $count times)"
              dollar_quote_error=1
            fi
          done <<< "$dollar_tags"
          
          if [ $dollar_quote_error -eq 1 ]; then
            echo "‚ùå Dollar quote validation failed for $sql_file"
            VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
          fi

          # 3. Check for required Liquibase headers
          if ! grep -q "^--liquibase formatted sql" "$sql_file"; then
            echo "‚ùå Missing Liquibase header in $sql_file"
            VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
          fi

          # 4. Check for changeset format
          if ! grep -q "^--changeset " "$sql_file"; then
            echo "‚ùå No changesets found in $sql_file"
            VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
          fi

          # 5. Check for potentially dangerous operations
          DANGEROUS_OPS=$(grep -in "DROP\|DELETE\|TRUNCATE" "$sql_file" | grep -v "^[[:space:]]*--" || true)
          if [ -n "$DANGEROUS_OPS" ]; then
            echo "‚ö†Ô∏è  Potentially dangerous operations found in $sql_file:"
            echo "$DANGEROUS_OPS"
            echo "   Please review these operations carefully"
          fi

          echo "‚úÖ Basic validation passed for $sql_file"
        done

        if [ $VALIDATION_ERRORS -gt 0 ]; then
          echo ""
          echo "‚ùå SQL validation failed with $VALIDATION_ERRORS error(s)"
          echo "üîß Please fix the syntax errors above before proceeding"
          exit 1
        else
          echo ""
          echo "‚úÖ All SQL files passed basic syntax validation"
        fi

    - name: Liquibase offline validation
      run: |
        echo "üß™ Running Liquibase offline validation for ${{ matrix.database }}..."

        # Create temporary offline configuration for validation
        cat > liquibase-${{ matrix.database }}-validation.properties << 'EOF'
        changelogFile=changelog-${{ matrix.database }}.xml
        url=offline:postgresql
        driver=org.postgresql.Driver
        logLevel=INFO
        logFile=liquibase-${{ matrix.database }}-validation.log
        outputFile=liquibase-${{ matrix.database }}-validation-output.txt
        EOF

        # Run Liquibase validation in offline mode
        if ./liquibase --defaults-file=liquibase-${{ matrix.database }}-validation.properties validate; then
          echo "‚úÖ Liquibase offline validation PASSED for ${{ matrix.database }}"
        else
          echo "‚ùå Liquibase offline validation FAILED for ${{ matrix.database }}"
          echo "üìÑ Validation log:"
          if [ -f "liquibase-${{ matrix.database }}-validation.log" ]; then
            cat "liquibase-${{ matrix.database }}-validation.log"
          fi
          exit 1
        fi

        # Generate SQL preview in offline mode to catch additional issues
        echo "üìã Generating SQL preview to validate changeset logic..."
        if ./liquibase --defaults-file=liquibase-${{ matrix.database }}-validation.properties update-sql > planned-changes-${{ matrix.database }}-validation.sql; then
          echo "‚úÖ SQL generation succeeded"

          # Show a preview of what would be executed
          echo "üìÑ SQL Preview (first 20 lines):"
          head -20 planned-changes-${{ matrix.database }}-validation.sql | nl

          # Check for safety patterns
          SAFETY_CHECKS=0
          if grep -q "IF NOT EXISTS\|CREATE OR REPLACE\|preconditions onFail:MARK_RAN" planned-changes-${{ matrix.database }}-validation.sql; then
            echo "‚úÖ Safety patterns detected (IF NOT EXISTS/CREATE OR REPLACE/preconditions)"
            SAFETY_CHECKS=$((SAFETY_CHECKS + 1))
          fi

          if ! grep -q "DROP TABLE\|DELETE FROM\|TRUNCATE" planned-changes-${{ matrix.database }}-validation.sql; then
            echo "‚úÖ No destructive operations detected"
            SAFETY_CHECKS=$((SAFETY_CHECKS + 1))
          else
            echo "‚ö†Ô∏è  Destructive operations detected - please review carefully"
          fi

          echo "üõ°Ô∏è  Safety checks passed: $SAFETY_CHECKS/2"
        else
          echo "‚ùå SQL generation failed"
          exit 1
        fi

        # Cleanup temporary files
        rm -f liquibase-${{ matrix.database }}-validation.properties
        rm -f liquibase-${{ matrix.database }}-validation.log
        rm -f liquibase-${{ matrix.database }}-validation-output.txt
        rm -f planned-changes-${{ matrix.database }}-validation.sql

    - name: Configure database connection
      run: |
        ./.github/scripts/configure-database.sh \
          ${{ matrix.database }} \
          ${{ vars.SECRET_NAME || 'liquibase-databases' }} \
          ${{ needs.discover-databases.outputs.test-mode }}

    - name: Create database if needed
      if: needs.discover-databases.outputs.test-mode == 'false'
      run: |
        echo "üèóÔ∏è Ensuring database exists for ${{ matrix.database }}..."

        # Extract database type and name from the configuration
        DB_TYPE=$(grep -E "^url=" liquibase-${{ matrix.database }}.properties | sed 's/url=jdbc://' | cut -d: -f1)

        # Extract database name based on database type
        DB_URL=$(grep -E "^url=" liquibase-${{ matrix.database }}.properties | sed 's/url=//')
        if [ "$DB_TYPE" = "sqlserver" ]; then
          # SQL Server uses databaseName= parameter
          DB_NAME=$(echo "$DB_URL" | sed -n 's/.*databaseName=\([^;]*\).*/\1/p')
        else
          # PostgreSQL, MySQL use /database format
          DB_NAME=$(echo "$DB_URL" | sed 's/.*\///' | sed 's/;.*//' | sed 's/?.*//')
        fi

        # Only create database in deploy mode (not test mode)
        SECRET_NAME="${{ vars.SECRET_NAME || 'liquibase-databases' }}"

        echo "üîß Creating database: $DB_NAME (type: $DB_TYPE)"

        if [ "$DB_TYPE" = "postgresql" ]; then
          if ! ./.github/scripts/create-database.sh postgresql "$DB_NAME" "$SECRET_NAME"; then
            echo "‚ùå Failed to create PostgreSQL database: $DB_NAME"
            exit 1
          fi
        elif [ "$DB_TYPE" = "mysql" ]; then
          if ! ./.github/scripts/create-database.sh mysql "$DB_NAME" "$SECRET_NAME"; then
            echo "‚ùå Failed to create MySQL database: $DB_NAME"
            exit 1
          fi
        elif [ "$DB_TYPE" = "sqlserver" ]; then
          echo "‚ö° Skipping SQL Server database creation (minimal setup mode)"
          echo "‚ÑπÔ∏è Assuming SQL Server database '$DB_NAME' already exists"
          echo "üí° If database doesn't exist, Liquibase will show connection errors"
        elif [ "$DB_TYPE" = "oracle" ]; then
          if ! ./.github/scripts/create-database.sh oracle "$DB_NAME" "$SECRET_NAME"; then
            echo "‚ùå Failed to create Oracle database: $DB_NAME"
            exit 1
          fi
        else
          echo "‚ÑπÔ∏è Unknown database type: $DB_TYPE - skipping database creation"
        fi

        echo "‚úÖ Database creation completed for: $DB_NAME"

    - name: Reset Liquibase tracking (if requested)
      if: needs.discover-databases.outputs.reset-mode == 'true'
      run: |
        echo "üîÑ RESET MODE: Dropping Liquibase tracking tables to force complete re-deployment"
        echo "‚ö†Ô∏è This will cause ALL changesets to be re-executed"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

        # Create a simple SQL script to drop Liquibase tables
        cat > reset_liquibase.sql << 'EOF'
        --liquibase formatted sql
        --changeset reset:drop-liquibase-tables
        BEGIN
            EXECUTE IMMEDIATE 'DROP TABLE DATABASECHANGELOG CASCADE CONSTRAINTS';
            EXCEPTION WHEN OTHERS THEN
                IF SQLCODE != -942 THEN RAISE; END IF; -- Ignore table not found
        END;
        /

        BEGIN
            EXECUTE IMMEDIATE 'DROP TABLE DATABASECHANGELOGLOCK CASCADE CONSTRAINTS';
            EXCEPTION WHEN OTHERS THEN
                IF SQLCODE != -942 THEN RAISE; END IF; -- Ignore table not found
        END;
        /
        EOF

        # Execute the reset using Liquibase's sql command
        if liquibase --defaults-file="liquibase-${{ matrix.database }}.properties" execute-sql --sql-file="reset_liquibase.sql"; then
            echo "‚úÖ Liquibase tracking tables dropped successfully"
        else
            echo "‚ö†Ô∏è Failed to drop tracking tables (they may not exist yet)"
        fi

        rm -f reset_liquibase.sql
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

    - name: Validate changelog
      run: |
        if ! ./.github/scripts/run-liquibase.sh ${{ matrix.database }} validate; then
          echo "‚ö†Ô∏è Validation failed, likely due to checksum mismatch. Clearing checksums..."
          ./.github/scripts/run-liquibase.sh ${{ matrix.database }} clear-checksums
          echo "‚úÖ Checksums cleared. Re-running validation..."
          ./.github/scripts/run-liquibase.sh ${{ matrix.database }} validate
        fi

    - name: Run deployment or generate test SQL
      run: |
        if [ "${{ needs.discover-databases.outputs.test-mode }}" = "true" ]; then
          echo "üß™ Running in TEST mode (branch push or PR validation)"
          echo "üìã This will validate changesets and generate SQL without making database changes"
          ./.github/scripts/run-liquibase.sh ${{ matrix.database }} update-sql true

          echo ""
          echo "üéØ TEST SUMMARY for ${{ matrix.database }}:"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Changelog validation: PASSED"
          echo "‚úÖ SQL generation: COMPLETED"
          echo "üìÅ Artifacts will be uploaded for review"
          echo "üöÄ Ready for deployment when PR is merged to main branch"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        else
          echo "üöÄ Running in DEPLOY mode (PR merged to main)"
          echo "üèóÔ∏è This will create databases and execute changesets in production"
          ./.github/scripts/run-liquibase.sh ${{ matrix.database }} update
          ./.github/scripts/run-liquibase.sh ${{ matrix.database }} status
        fi

    - name: Cleanup sensitive files
      if: always()
      run: ./.github/scripts/cleanup.sh ${{ matrix.database }}

    - name: Show workflow status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "üéâ Workflow completed successfully for ${{ matrix.database }}"
        else
          echo "‚ùå Workflow failed for ${{ matrix.database }}"
          echo "üîç Check the logs above for error details"
        fi

    - name: Upload test results
      if: needs.discover-databases.outputs.test-mode == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.database }}
        path: |
          planned-changes-${{ matrix.database }}.sql
          liquibase-${{ matrix.database }}.log

    - name: Upload deployment artifacts
      if: needs.discover-databases.outputs.test-mode == 'false'
      uses: actions/upload-artifact@v4
      with:
        name: deployment-results-${{ matrix.database }}
        path: |
          planned-changes-${{ matrix.database }}.sql
          liquibase-${{ matrix.database }}.log
          liquibase-${{ matrix.database }}-output.txt

    - name: Upload logs on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: failure-logs-${{ matrix.database }}
        path: |
          liquibase-${{ matrix.database }}.log
          liquibase-${{ matrix.database }}-output.txt