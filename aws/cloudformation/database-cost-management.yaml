AWSTemplateFormatVersion: '2010-09-09'
Description: 'Automated RDS database shutdown for cost management'

Parameters:
  ScheduleExpression:
    Type: String
    Default: 'rate(30 minutes)'
    Description: 'How often to check and stop databases (e.g., rate(30 minutes) or cron(0 22 * * ? *))'

  FunctionName:
    Type: String
    Default: 'rds-database-stopper'
    Description: 'Name for the Lambda function'

Resources:
  # IAM Role for Lambda function
  DatabaseStopperRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${FunctionName}-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: RDSStopperPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - rds:DescribeDBInstances
                  - rds:StopDBInstance
                  - rds:ListTagsForResource
                Resource: '*'
                Condition:
                  StringEquals:
                    'aws:RequestedRegion': !Ref 'AWS::Region'

  # Lambda function
  DatabaseStopperFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref FunctionName
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt DatabaseStopperRole.Arn
      Timeout: 300
      Description: 'Automatically stops RDS databases to reduce costs'
      Code:
        ZipFile: |
          import boto3
          import json
          import logging
          from typing import Dict, List, Any

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
              """
              AWS Lambda function to automatically stop RDS databases to reduce costs.
              Designed to run on a schedule to keep databases shut down when not in use.
              """

              rds_client = boto3.client('rds')

              stopped_instances = []
              errors = []

              try:
                  # Get all RDS instances
                  response = rds_client.describe_db_instances()

                  for db_instance in response['DBInstances']:
                      db_identifier = db_instance['DBInstanceIdentifier']
                      db_status = db_instance['DBInstanceStatus']
                      engine = db_instance['Engine']

                      logger.info(f"Processing database: {db_identifier} (Status: {db_status}, Engine: {engine})")

                      # Only attempt to stop databases that are currently available
                      if db_status == 'available':
                          try:
                              # Check if this is a database we should manage
                              # Skip production databases or databases with specific tags
                              if should_stop_database(rds_client, db_identifier):
                                  logger.info(f"Stopping database: {db_identifier}")

                                  rds_client.stop_db_instance(
                                      DBInstanceIdentifier=db_identifier
                                  )

                                  stopped_instances.append({
                                      'identifier': db_identifier,
                                      'engine': engine,
                                      'status': 'stop_initiated'
                                  })

                              else:
                                  logger.info(f"Skipping database {db_identifier} - marked as persistent or production")

                          except Exception as e:
                              error_msg = f"Failed to stop {db_identifier}: {str(e)}"
                              logger.error(error_msg)
                              errors.append(error_msg)

                      elif db_status in ['stopped', 'stopping']:
                          logger.info(f"Database {db_identifier} is already stopped or stopping")

                      else:
                          logger.info(f"Database {db_identifier} is in {db_status} state - skipping")

              except Exception as e:
                  error_msg = f"Failed to list RDS instances: {str(e)}"
                  logger.error(error_msg)
                  errors.append(error_msg)

              # Return summary
              result = {
                  'statusCode': 200,
                  'body': {
                      'stopped_instances': stopped_instances,
                      'total_stopped': len(stopped_instances),
                      'errors': errors,
                      'timestamp': context.aws_request_id
                  }
              }

              logger.info(f"Lambda execution completed. Stopped {len(stopped_instances)} databases.")
              return result

          def should_stop_database(rds_client: boto3.client, db_identifier: str) -> bool:
              """
              Determine if a database should be automatically stopped.
              Returns False for production databases or databases tagged as persistent.
              """
              try:
                  # Get database tags
                  response = rds_client.list_tags_for_resource(
                      ResourceName=f"arn:aws:rds:{boto3.Session().region_name}:{boto3.client('sts').get_caller_identity()['Account']}:db:{db_identifier}"
                  )

                  tags = {tag['Key']: tag['Value'] for tag in response.get('TagList', [])}

                  # Skip databases with these tags
                  if tags.get('Environment', '').lower() == 'production':
                      return False

                  if tags.get('AutoStop', '').lower() == 'false':
                      return False

                  if tags.get('Persistent', '').lower() == 'true':
                      return False

                  # Skip databases with 'prod' in the name
                  if 'prod' in db_identifier.lower():
                      return False

                  # Default to allowing stop for dev/test databases
                  return True

              except Exception as e:
                  logger.error(f"Failed to check tags for {db_identifier}: {str(e)}")
                  # If we can't check tags, err on the side of caution
                  return False

  # CloudWatch Event Rule for scheduling
  DatabaseStopperSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${FunctionName}-schedule'
      Description: 'Schedule for stopping RDS databases'
      ScheduleExpression: !Ref ScheduleExpression
      State: ENABLED
      Targets:
        - Arn: !GetAtt DatabaseStopperFunction.Arn
          Id: 'DatabaseStopperTarget'

  # Permission for EventBridge to invoke Lambda
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DatabaseStopperFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt DatabaseStopperSchedule.Arn

  # CloudWatch Log Group for Lambda function
  DatabaseStopperLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${FunctionName}'
      RetentionInDays: 7

Outputs:
  LambdaFunctionArn:
    Description: 'ARN of the database stopper Lambda function'
    Value: !GetAtt DatabaseStopperFunction.Arn

  ScheduleArn:
    Description: 'ARN of the EventBridge rule'
    Value: !GetAtt DatabaseStopperSchedule.Arn

  FunctionName:
    Description: 'Name of the Lambda function'
    Value: !Ref DatabaseStopperFunction

  LogGroupName:
    Description: 'CloudWatch Log Group for monitoring'
    Value: !Ref DatabaseStopperLogGroup